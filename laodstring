local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- Ensure full noclip for everything except coins
game:GetService("RunService").Stepped:Connect(function()
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            -- Set collision off for all parts except coins
            if part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("MainCoin") then
                -- Keep coins' collision intact
                part.CanCollide = true
            else
                -- Disable collision for everything else
                part.CanCollide = false
            end
        end
    end
end)

local FLY_SPEED = 50
local ARRIVAL_THRESHOLD = 1 -- Reduce so it stops exactly inside the coin
local visitedCoins = {}

local function forceMoveTo(targetPos)
    hrp.Velocity = Vector3.zero
    local startTime = tick()

    while (hrp.Position - targetPos).Magnitude > ARRIVAL_THRESHOLD do
        if tick() - startTime > 10 then -- Timeout failsafe
            hrp.Velocity = Vector3.zero
            return false
        end
        hrp.Velocity = (targetPos - hrp.Position).Unit * FLY_SPEED
        task.wait()
    end

    hrp.Velocity = Vector3.zero
    return true
end

local function getCoins()
    local coins = {}
    for _, coin in ipairs(workspace:GetDescendants()) do
        if coin:IsA("MeshPart") and coin.Name == "MainCoin" and not visitedCoins[coin] then
            table.insert(coins, coin)
        end
    end
    return coins
end

local function getClosestCoin()
    local coins = getCoins()
    local closestCoin = nil
    local shortestDistance = math.huge

    for _, coin in ipairs(coins) do
        local distance = (hrp.Position - coin.Position).Magnitude
        if distance < shortestDistance then
            shortestDistance = distance
            closestCoin = coin
        end
    end

    return closestCoin
end

while true do
    local coin = getClosestCoin()
    
    if not coin then
        task.wait(5)
        continue
    end

    local targetPos = coin.Position -- Directly inside the coin
    if forceMoveTo(targetPos) then
        visitedCoins[coin] = true
        coin:Destroy()
    end

    task.wait(1)
end
